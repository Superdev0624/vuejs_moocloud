/**
 * @popperjs/core v2.5.4 - MIT License
 */

'use strict'; !(function (e, t) { typeof exports === 'object' && typeof module !== 'undefined' ? t(exports) : typeof define === 'function' && define.amd ? define(['exports'], t) : t((e = e || self).Popper = {}) }(this, function (e) { function t (e) { return { width: (e = e.getBoundingClientRect()).width, height: e.height, top: e.top, right: e.right, bottom: e.bottom, left: e.left, x: e.left, y: e.top } } function n (e) { return e.toString() !== '[object Window]' ? (e = e.ownerDocument) && e.defaultView || window : e } function r (e) { return { scrollLeft: (e = n(e)).pageXOffset, scrollTop: e.pageYOffset } } function o (e) { return e instanceof n(e).Element || e instanceof Element } function i (e) { return e instanceof n(e).HTMLElement || e instanceof HTMLElement } function a (e) { return e ? (e.nodeName || '').toLowerCase() : null } function s (e) { return ((o(e) ? e.ownerDocument : e.document) || window.document).documentElement } function f (e) { return t(s(e)).left + r(e).scrollLeft } function c (e) { return n(e).getComputedStyle(e) } function p (e) { return e = c(e), /auto|scroll|overlay|hidden/.test(e.overflow + e.overflowY + e.overflowX) } function l (e, o, c) { void 0 === c && (c = !1); const l = s(o); e = t(e); const u = i(o); let d = { scrollLeft: 0, scrollTop: 0 }; let m = { x: 0, y: 0 }; return (u || !u && !c) && ((a(o) !== 'body' || p(l)) && (d = o !== n(o) && i(o) ? { scrollLeft: o.scrollLeft, scrollTop: o.scrollTop } : r(o)), i(o) ? ((m = t(o)).x += o.clientLeft, m.y += o.clientTop) : l && (m.x = f(l))), { x: e.left + d.scrollLeft - m.x, y: e.top + d.scrollTop - m.y, width: e.width, height: e.height } } function u (e) { return { x: e.offsetLeft, y: e.offsetTop, width: e.offsetWidth, height: e.offsetHeight } } function d (e) { return a(e) === 'html' ? e : e.assignedSlot || e.parentNode || e.host || s(e) } function m (e, t) { void 0 === t && (t = []); let r = (function e (t) { return ['html', 'body', '#document'].includes(a(t)) ? t.ownerDocument.body : i(t) && p(t) ? t : e(d(t)) }(e)); e = a(r) === 'body'; const o = n(r); return r = e ? [o].concat(o.visualViewport || [], p(r) ? r : []) : r, t = t.concat(r), e ? t : t.concat(m(d(r))) } function h (e) { if (!i(e) || c(e).position === 'fixed') { return null } if (e = e.offsetParent) { const t = s(e); if (a(e) === 'body' && c(e).position === 'static' && c(t).position !== 'static') { return t } } return e } function g (e) { for (var t = n(e), r = h(e); r && ['table', 'td', 'th'].includes(a(r)) && c(r).position === 'static';) { r = h(r) } if (r && a(r) === 'body' && c(r).position === 'static') { return t } if (!r) { e: { for (e = d(e); i(e) && !['html', 'body'].includes(a(e));) { if ((r = c(e)).transform !== 'none' || r.perspective !== 'none' || r.willChange && r.willChange !== 'auto') { r = e; break e }e = e.parentNode }r = null } } return r || t } function v (e) { const t = new Map(); const n = new Set(); const r = []; return e.forEach(function (e) { t.set(e.name, e) }), e.forEach(function (e) { n.has(e.name) || (function e (o) { n.add(o.name), [].concat(o.requires || [], o.requiresIfExists || []).forEach(function (r) { n.has(r) || (r = t.get(r)) && e(r) }), r.push(o) }(e)) }), r } function b (e) { let t; return function () { return t || (t = new Promise(function (n) { Promise.resolve().then(function () { t = void 0, n(e()) }) })), t } } function y (e) { return e.split('-')[0] } function O (e, t) { let r; const o = t.getRootNode && t.getRootNode(); if (e.contains(t)) { return !0 } if ((r = o) && (r = o instanceof (r = n(o).ShadowRoot) || o instanceof ShadowRoot), r) { do { if (t && e.isSameNode(t)) { return !0 } t = t.parentNode || t.host } while (t) } return !1 } function w (e) { return Object.assign(Object.assign({}, e), {}, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height }) } function x (e, o) { if (o === 'viewport') { o = n(e); var a = s(e); o = o.visualViewport; var p = a.clientWidth; a = a.clientHeight; var l = 0; var u = 0; o && (p = o.width, a = o.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (l = o.offsetLeft, u = o.offsetTop)), e = w(e = { width: p, height: a, x: l + f(e), y: u }) } else { i(o) ? ((e = t(o)).top += o.clientTop, e.left += o.clientLeft, e.bottom = e.top + o.clientHeight, e.right = e.left + o.clientWidth, e.width = o.clientWidth, e.height = o.clientHeight, e.x = e.left, e.y = e.top) : (u = s(e), e = s(u), l = r(u), o = u.ownerDocument.body, p = Math.max(e.scrollWidth, e.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), a = Math.max(e.scrollHeight, e.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), u = -l.scrollLeft + f(u), l = -l.scrollTop, c(o || e).direction === 'rtl' && (u += Math.max(e.clientWidth, o ? o.clientWidth : 0) - p), e = w({ width: p, height: a, x: u, y: l })) } return e } function j (e, t, n) { return t = t === 'clippingParents' ? (function (e) { const t = m(d(e)); const n = ['absolute', 'fixed'].includes(c(e).position) && i(e) ? g(e) : e; return o(n) ? t.filter(function (e) { return o(e) && O(e, n) && a(e) !== 'body' }) : [] }(e)) : [].concat(t), (n = (n = [].concat(t, [n])).reduce(function (t, n) { return n = x(e, n), t.top = Math.max(n.top, t.top), t.right = Math.min(n.right, t.right), t.bottom = Math.min(n.bottom, t.bottom), t.left = Math.max(n.left, t.left), t }, x(e, n[0]))).width = n.right - n.left, n.height = n.bottom - n.top, n.x = n.left, n.y = n.top, n } function M (e) { return ['top', 'bottom'].includes(e) ? 'x' : 'y' } function E (e) { const t = e.reference; const n = e.element; let r = (e = e.placement) ? y(e) : null; e = e ? e.split('-')[1] : null; let o = t.x + t.width / 2 - n.width / 2; let i = t.y + t.height / 2 - n.height / 2; switch (r) { case 'top':o = { x: o, y: t.y - n.height }; break; case 'bottom':o = { x: o, y: t.y + t.height }; break; case 'right':o = { x: t.x + t.width, y: i }; break; case 'left':o = { x: t.x - n.width, y: i }; break; default:o = { x: t.x, y: t.y } } if ((r = r ? M(r) : null) != null) { switch (i = r === 'y' ? 'height' : 'width', e) { case 'start':o[r] = Math.floor(o[r]) - Math.floor(t[i] / 2 - n[i] / 2); break; case 'end':o[r] = Math.floor(o[r]) + Math.ceil(t[i] / 2 - n[i] / 2) } } return o } function D (e) { return Object.assign(Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }), e) } function P (e, t) { return t.reduce(function (t, n) { return t[n] = e, t }, {}) } function L (e, n) { void 0 === n && (n = {}); let r = n; n = void 0 === (n = r.placement) ? e.placement : n; let i = r.boundary; let a = void 0 === i ? 'clippingParents' : i; let f = void 0 === (i = r.rootBoundary) ? 'viewport' : i; i = void 0 === (i = r.elementContext) ? 'popper' : i; let c = r.altBoundary; let p = void 0 !== c && c; r = D(typeof (r = void 0 === (r = r.padding) ? 0 : r) !== 'number' ? r : P(r, T)); const l = e.elements.reference; c = e.rects.popper, a = j(o(p = e.elements[p ? i === 'popper' ? 'reference' : 'popper' : i]) ? p : p.contextElement || s(e.elements.popper), a, f), p = E({ reference: f = t(l), element: c, strategy: 'absolute', placement: n }), c = w(Object.assign(Object.assign({}, c), p)), f = i === 'popper' ? c : f; const u = { top: a.top - f.top + r.top, bottom: f.bottom - a.bottom + r.bottom, left: a.left - f.left + r.left, right: f.right - a.right + r.right }; if (e = e.modifiersData.offset, i === 'popper' && e) { const d = e[n]; Object.keys(u).forEach(function (e) { const t = ['right', 'bottom'].includes(e) ? 1 : -1; const n = ['top', 'bottom'].includes(e) ? 'y' : 'x'; u[e] += d[n] * t }) } return u } function k () { for (var e = arguments.length, t = Array(e), n = 0; n < e; n++) { t[n] = arguments[n] } return !t.some(function (e) { return !(e && typeof e.getBoundingClientRect === 'function') }) } function B (e) { void 0 === e && (e = {}); const t = e.defaultModifiers; const n = void 0 === t ? [] : t; const r = void 0 === (e = e.defaultOptions) ? V : e; return function (e, t, i) { function a () { f.forEach(function (e) { return e() }), f = [] } void 0 === i && (i = r); let s = { placement: 'bottom', orderedModifiers: [], options: Object.assign(Object.assign({}, V), r), modifiersData: {}, elements: { reference: e, popper: t }, attributes: {}, styles: {} }; var f = []; let c = !1; var p = { state: s, setOptions (i) { return a(), s.options = Object.assign(Object.assign(Object.assign({}, r), s.options), i), s.scrollParents = { reference: o(e) ? m(e) : e.contextElement ? m(e.contextElement) : [], popper: m(t) }, i = (function (e) { const t = v(e); return N.reduce(function (e, n) { return e.concat(t.filter(function (e) { return e.phase === n })) }, []) }(function (e) { const t = e.reduce(function (e, t) { const n = e[t.name]; return e[t.name] = n ? Object.assign(Object.assign(Object.assign({}, n), t), {}, { options: Object.assign(Object.assign({}, n.options), t.options), data: Object.assign(Object.assign({}, n.data), t.data) }) : t, e }, {}); return Object.keys(t).map(function (e) { return t[e] }) }([].concat(n, s.options.modifiers)))), s.orderedModifiers = i.filter(function (e) { return e.enabled }), s.orderedModifiers.forEach(function (e) { let t = e.name; let n = e.options; n = void 0 === n ? {} : n, typeof (e = e.effect) === 'function' && (t = e({ state: s, name: t, instance: p, options: n }), f.push(t || function () {})) }), p.update() }, forceUpdate () { if (!c) { let e = s.elements; let t = e.reference; if (k(t, e = e.popper)) { for (s.rects = { reference: l(t, g(e), s.options.strategy === 'fixed'), popper: u(e) }, s.reset = !1, s.placement = s.options.placement, s.orderedModifiers.forEach(function (e) { return s.modifiersData[e.name] = Object.assign({}, e.data) }), t = 0; t < s.orderedModifiers.length; t++) { if (!0 === s.reset) { s.reset = !1, t = -1 } else { let n = s.orderedModifiers[t]; e = n.fn; let r = n.options; r = void 0 === r ? {} : r, n = n.name, typeof e === 'function' && (s = e({ state: s, options: r, name: n, instance: p }) || s) } } } } }, update: b(function () { return new Promise(function (e) { p.forceUpdate(), e(s) }) }), destroy () { a(), c = !0 } }; return k(e, t) ? (p.setOptions(i).then(function (e) { !c && i.onFirstUpdate && i.onFirstUpdate(e) }), p) : p } } function W (e) { let t; let r = e.popper; const o = e.popperRect; const i = e.placement; let a = e.offsets; const f = e.position; const c = e.gpuAcceleration; const p = e.adaptive; let l = window.devicePixelRatio || 1; e = Math.round(a.x * l) / l || 0, l = Math.round(a.y * l) / l || 0; const u = a.hasOwnProperty('x'); a = a.hasOwnProperty('y'); let d; let m = 'left'; let h = 'top'; const v = window; if (p) { let b = g(r); b === n(r) && (b = s(r)), i === 'top' && (h = 'bottom', l -= b.clientHeight - o.height, l *= c ? 1 : -1), i === 'left' && (m = 'right', e -= b.clientWidth - o.width, e *= c ? 1 : -1) } return r = Object.assign({ position: f }, p && z), c ? Object.assign(Object.assign({}, r), {}, ((d = {})[h] = a ? '0' : '', d[m] = u ? '0' : '', d.transform = (v.devicePixelRatio || 1) < 2 ? 'translate(' + e + 'px, ' + l + 'px)' : 'translate3d(' + e + 'px, ' + l + 'px, 0)', d)) : Object.assign(Object.assign({}, r), {}, ((t = {})[h] = a ? l + 'px' : '', t[m] = u ? e + 'px' : '', t.transform = '', t)) } function A (e) { return e.replace(/left|right|bottom|top/g, function (e) { return G[e] }) } function H (e) { return e.replace(/start|end/g, function (e) { return J[e] }) } function R (e, t, n) { return void 0 === n && (n = { x: 0, y: 0 }), { top: e.top - t.height - n.y, right: e.right - t.width + n.x, bottom: e.bottom - t.height + n.y, left: e.left - t.width - n.x } } function S (e) { return ['top', 'right', 'bottom', 'left'].some(function (t) { return e[t] >= 0 }) } var T = ['top', 'bottom', 'right', 'left']; const q = T.reduce(function (e, t) { return e.concat([t + '-start', t + '-end']) }, []); const C = [].concat(T, ['auto']).reduce(function (e, t) { return e.concat([t, t + '-start', t + '-end']) }, []); var N = 'beforeRead read afterRead beforeMain main afterMain beforeWrite write afterWrite'.split(' '); var V = { placement: 'bottom', modifiers: [], strategy: 'absolute' }; const I = { passive: !0 }; const _ = { name: 'eventListeners', enabled: !0, phase: 'write', fn () {}, effect (e) { const t = e.state; const r = e.instance; const o = (e = e.options).scroll; const i = void 0 === o || o; const a = void 0 === (e = e.resize) || e; const s = n(t.elements.popper); const f = [].concat(t.scrollParents.reference, t.scrollParents.popper); return i && f.forEach(function (e) { e.addEventListener('scroll', r.update, I) }), a && s.addEventListener('resize', r.update, I), function () { i && f.forEach(function (e) { e.removeEventListener('scroll', r.update, I) }), a && s.removeEventListener('resize', r.update, I) } }, data: {} }; const U = { name: 'popperOffsets', enabled: !0, phase: 'read', fn (e) { const t = e.state; t.modifiersData[e.name] = E({ reference: t.rects.reference, element: t.rects.popper, strategy: 'absolute', placement: t.placement }) }, data: {} }; var z = { top: 'auto', right: 'auto', bottom: 'auto', left: 'auto' }; const F = { name: 'computeStyles', enabled: !0, phase: 'beforeWrite', fn (e) { const t = e.state; let n = e.options; e = void 0 === (e = n.gpuAcceleration) || e, n = void 0 === (n = n.adaptive) || n, e = { placement: y(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: e }, t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign(Object.assign({}, t.styles.popper), W(Object.assign(Object.assign({}, e), {}, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: n })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign(Object.assign({}, t.styles.arrow), W(Object.assign(Object.assign({}, e), {}, { offsets: t.modifiersData.arrow, position: 'absolute', adaptive: !1 })))), t.attributes.popper = Object.assign(Object.assign({}, t.attributes.popper), {}, { 'data-popper-placement': t.placement }) }, data: {} }; const X = { name: 'applyStyles', enabled: !0, phase: 'write', fn (e) { const t = e.state; Object.keys(t.elements).forEach(function (e) { const n = t.styles[e] || {}; const r = t.attributes[e] || {}; const o = t.elements[e]; i(o) && a(o) && (Object.assign(o.style, n), Object.keys(r).forEach(function (e) { const t = r[e]; !1 === t ? o.removeAttribute(e) : o.setAttribute(e, !0 === t ? '' : t) })) }) }, effect (e) { const t = e.state; const n = { popper: { position: t.options.strategy, left: '0', top: '0', margin: '0' }, arrow: { position: 'absolute' }, reference: {} }; return Object.assign(t.elements.popper.style, n.popper), t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function () { Object.keys(t.elements).forEach(function (e) { const r = t.elements[e]; const o = t.attributes[e] || {}; e = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : n[e]).reduce(function (e, t) { return e[t] = '', e }, {}), i(r) && a(r) && (Object.assign(r.style, e), Object.keys(o).forEach(function (e) { r.removeAttribute(e) })) }) } }, requires: ['computeStyles'] }; const Y = { name: 'offset', enabled: !0, phase: 'main', requires: ['popperOffsets'], fn (e) { const t = e.state; const n = e.name; const r = void 0 === (e = e.options.offset) ? [0, 0] : e; let o = (e = C.reduce(function (e, n) { let o = t.rects; let i = y(n); const a = 0 <= ['left', "top"].indexOf(i) ? -1 : 1; let s = typeof r==='function' ? r(Object.assign(Object.assign({}, o), {}, { placement: n })) : r; return o = (o = s[0]) || 0, s = ((s = s[1]) || 0) * a, i = ['left', "right"].includes(i) ? { x: s, y: o } : { x: o, y: s }, e[n] = i, e }, {}))[t.placement]; const i = o.x; o = o.y, t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += i, t.modifiersData.popperOffsets.y += o), t.modifiersData[n] = e } }; var G = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' }; var J = { start: 'end', end: 'start' }; const K = { name: 'flip', enabled: !0, phase: 'main', fn (e) { const t = e.state; let n = e.options; if (e = e.name, !t.modifiersData[e]._skip) { let r = n.mainAxis; r = void 0 === r || r; let o = n.altAxis; o = void 0 === o || o; let i = n.fallbackPlacements; const a = n.padding; const s = n.boundary; const f = n.rootBoundary; const c = n.altBoundary; let p = n.flipVariations; const l = void 0 === p || p; const u = n.allowedAutoPlacements; p = y(n = t.options.placement), i = i || (p !== n && l ? (function (e) { if (y(e) === 'auto') { return [] } const t = A(e); return [H(e), t, H(t)] }(n)) : [A(n)]); const d = [n].concat(i).reduce(function (e, n) { return e.concat(y(n) === 'auto' ? (function (e, t) { void 0 === t && (t = {}); let n = t.boundary; let r = t.rootBoundary; let o = t.padding; let i = t.flipVariations; let a = t.allowedAutoPlacements; let s = void 0 === a ? C : a; let f = t.placement.split('-')[1]; (i = (t = f ? i ? q : q.filter(function(e){return e.split("-")[1]===f}) : T).filter(function(e){return 0<=s.indexOf(e)})).length === 0 && (i = t); let c = i.reduce(function (t, i) { return t[i] = L(e, { placement: i, boundary: n, rootBoundary: r, padding: o })[y(i)], t }, {}); return Object.keys(c).sort(function (e, t) { return c[e] - c[t] }) }(t, { placement: n, boundary: s, rootBoundary: f, padding: a, flipVariations: l, allowedAutoPlacements: u })) : n) }, []); n = t.rects.reference, i = t.rects.popper; const m = new Map(); p = !0; for (var h = d[0], g = 0; g < d.length; g++) { const v = d[g]; const b = y(v); let O = v.split('-')[1] === 'start'; let w = ['top', 'bottom'].includes(b); let x = w ? 'width' : 'height'; const j = L(t, { placement: v, boundary: s, rootBoundary: f, altBoundary: c, padding: a }); if (O = w ? O ? 'right' : 'left' : O ? 'bottom' : 'top', n[x] > i[x] && (O = A(O)), x = A(O), w = [], r && w.push(j[b] <= 0), o && w.push(j[O] <= 0, j[x] <= 0), w.every(function (e) { return e })) { h = v, p = !1; break }m.set(v, w) } if (p) { for (r = function (e) { const t = d.find(function (t) { if (t = m.get(t)) {return t.slice(0, e).every(function(e){return e})} }); if (t) { return h = t, 'break' } }, o = l ? 3 : 1; o > 0 && r(o) !== 'break'; o--) { ; } }t.placement !== h && (t.modifiersData[e]._skip = !0, t.placement = h, t.reset = !0) } }, requiresIfExists: ['offset'], data: { _skip: !1 } }; const Q = { name: 'preventOverflow', enabled: !0, phase: 'main', fn (e) { const t = e.state; let n = e.options; e = e.name; let r = n.mainAxis; let o = void 0 === r || r; r = void 0 !== (r = n.altAxis) && r; let i = n.tether; i = void 0 === i || i; let a = n.tetherOffset; let s = void 0 === a ? 0 : a; n = L(t, { boundary: n.boundary, rootBoundary: n.rootBoundary, padding: n.padding, altBoundary: n.altBoundary }), a = y(t.placement); let f = t.placement.split('-')[1]; let c = !f; const p = M(a); a = p === 'x' ? 'y' : 'x'; const l = t.modifiersData.popperOffsets; let d = t.rects.reference; let m = t.rects.popper; let h = typeof s === 'function' ? s(Object.assign(Object.assign({}, t.rects), {}, { placement: t.placement })) : s; if (s = { x: 0, y: 0 }, l) { if (o) { let v = p === 'y' ? 'top' : 'left'; let b = p === 'y' ? 'bottom' : 'right'; const O = p === 'y' ? 'height' : 'width'; o = l[p]; const w = l[p] + n[v]; const x = l[p] - n[b]; const j = i ? -m[O] / 2 : 0; let E = f === 'start' ? d[O] : m[O]; f = f === 'start' ? -m[O] : -d[O], m = t.elements.arrow, m = i && m ? u(m) : { width: 0, height: 0 }; const D = t.modifiersData['arrow#persistent'] ? t.modifiersData['arrow#persistent'].padding : { top: 0, right: 0, bottom: 0, left: 0 }; v = D[v], b = D[b], m = Math.max(0, Math.min(d[O], m[O])), E = c ? d[O] / 2 - j - m - v - h : E - m - v - h, c = c ? -d[O] / 2 + j + m + b + h : f + m + b + h, h = t.elements.arrow && g(t.elements.arrow), d = t.modifiersData.offset ? t.modifiersData.offset[t.placement][p] : 0, h = l[p] + E - d - (h ? p === 'y' ? h.clientTop || 0 : h.clientLeft || 0 : 0), c = l[p] + c - d, i = Math.max(i ? Math.min(w, h) : w, Math.min(o, i ? Math.max(x, c) : x)), l[p] = i, s[p] = i - o }r && (r = l[a], i = Math.max(r + n[p === 'x' ? 'top' : 'left'], Math.min(r, r - n[p === 'x' ? 'bottom' : 'right'])), l[a] = i, s[a] = i - r), t.modifiersData[e] = s } }, requiresIfExists: ['offset'] }; const Z = { name: 'arrow', enabled: !0, phase: 'main', fn (e) { let t; const n = e.state; e = e.name; let r = n.elements.arrow; let o = n.modifiersData.popperOffsets; let i = y(n.placement); const a = M(i); if (i = ['left', 'right'].includes(i) ? 'height' : 'width', r && o) { const s = n.modifiersData[e + '#persistent'].padding; const f = u(r); const c = a === 'y' ? 'top' : 'left'; const p = a === 'y' ? 'bottom' : 'right'; let l = n.rects.reference[i] + n.rects.reference[a] - o[a] - n.rects.popper[i]; o = o[a] - n.rects.reference[a], l = (r = (r = g(r)) ? a === 'y' ? r.clientHeight || 0 : r.clientWidth || 0 : 0) / 2 - f[i] / 2 + (l / 2 - o / 2), i = Math.max(s[c], Math.min(l, r - f[i] - s[p])), n.modifiersData[e] = ((t = {})[a] = i, t.centerOffset = i - l, t) } }, effect (e) { const t = e.state; let n = e.options; e = e.name; let r = n.element; if (r = void 0 === r ? '[data-popper-arrow]' : r, n = void 0 === (n = n.padding) ? 0 : n, r != null) { if (typeof r === 'string' && !(r = t.elements.popper.querySelector(r))) { return } O(t.elements.popper, r) && (t.elements.arrow = r, t.modifiersData[e + '#persistent'] = { padding: D(typeof n !== 'number' ? n : P(n, T)) }) } }, requires: ['popperOffsets'], requiresIfExists: ['preventOverflow'] }; const $ = { name: 'hide', enabled: !0, phase: 'main', requiresIfExists: ['preventOverflow'], fn (e) { const t = e.state; e = e.name; let n = t.rects.reference; let r = t.rects.popper; let o = t.modifiersData.preventOverflow; const i = L(t, { elementContext: 'reference' }); let a = L(t, { altBoundary: !0 }); n = R(i, n), r = R(a, r, o), o = S(n), a = S(r), t.modifiersData[e] = { referenceClippingOffsets: n, popperEscapeOffsets: r, isReferenceHidden: o, hasPopperEscaped: a }, t.attributes.popper = Object.assign(Object.assign({}, t.attributes.popper), {}, { 'data-popper-reference-hidden': o, 'data-popper-escaped': a }) } }; const ee = B({ defaultModifiers: [_, U, F, X] }); const te = [_, U, F, X, Y, K, Q, Z, $]; const ne = B({ defaultModifiers: te }); e.applyStyles = X, e.arrow = Z, e.computeStyles = F, e.createPopper = ne, e.createPopperLite = ee, e.defaultModifiers = te, e.detectOverflow = L, e.eventListeners = _, e.flip = K, e.hide = $, e.offset = Y, e.popperGenerator = B, e.popperOffsets = U, e.preventOverflow = Q, Object.defineProperty(e, '__esModule', { value: !0 }) }))
// # sourceMappingURL=popper.min.js.map
